% ---------------------------------- DESIGN -------------------------------------

\chapter{Design}

\begin{comment}
In questo capitolo si spiegano le strategie messe in campo per realizzare la soluzione ai problemi identificati nell'analisi.

Si parte da una visione architetturale, il cui scopo è informare il lettore di quale sia il funzionamento dell'applicativo realizzato ad alto livello.
%
In particolare, è necessario descrivere accuratamente in che modo i componenti principali del sistema si coordinano fra loro.
%
A seguire, si dettagliano alcune parti del design, quelle maggiormente rilevanti al fine di chiarificare la logica con cui sono stati risolti i problemi dell'applicazione.
\end{comment}

\section{Architettura}

\textsf{\small L'obiettivo del team era quello di poter lavorare ognuno alla propria parte indipendentemente ed evitando conflitti, per poi poterle collegare tutte assieme alla fine.}\\

\textsf{\small Il progetto sfrutta quindi il pattern architetturale \textbf{MVC} (\emph{M}odel \emph{V}iew \emph{C}ontroller) che permette di suddividere la gestione dell'applicativo in tre parti separate: }\\

\begin{itemize} %TODO: ingrandire questa parte oppure scrivere di più nell'introduzione del Design.
	\item \textsf{\small \textbf{Model}: dove vengono effettivamente modellate le entità di gioco. In questa parte vengono gestiti tutti gli aspetti riguardanti la logica, la gestione, la fisica, le caratteristiche e il comportamento delle componenti di gioco.}
	%si occupa dell'interfaccia grafica
	\item \textsf{\small \textbf{View}: si occupa degli aspetti grafici, quali esporre le effettive entità del \emph{Model} sullo schermo di gioco. La \emph{View} comprende anche il menù di gioco e la schermata di fine partita per esaminare i risultati della classifica. Riguarda, inoltre, anche la parte di generazione delle mappa che comprende vari tipi di sfondi e relative piattaforme in tema, monete, oggetti, armi e nemici.}
	% Inoltre, riguarda anche
	\item \textsf{\small \textbf{Controller}: è il concreto ponte, tra il \emph{Model} e la \emph{View}, consente di collegare la parte logica con quella visiva. La sua funzione è quella di ricevere input della tastiera dall'utente, inviarlo al \emph{Model} per essere elaborato e alla \emph{View} per avere un riscontro visivo.}
\end{itemize}

\textsf{\small Di seguito, un UML riguardante il pattern architetturale \textbf{MVC} utilizzato:}\\

\begin{figure}[htp]
	\includegraphics[width=1.2\linewidth]{./img/mvc.png}
	\caption{Schema UML del pattern architetturale MVC.}
	\label{img:mvc}
\end{figure}

%\newpage

\begin{comment}

Questa sezione spiega come le componenti principali del software interagiscono fra loro.
%
In particolare, qui va spiegato \textbf{se} e \textbf{come} è stato utilizzato il pattern
architetturale model-view-controller (e/o alcune sue declinazioni specifiche, come entity-control-boundary).

Se non è stato utilizzato MVC, va spiegata in maniera molto accurata l'architettura scelta, giustificandola in modo appropriato.

Se è stato scelto MVC, vanno identificate con precisione le interfacce e classi che rappresentano i punti d'ingresso per modello, view, e controller.
Raccomandiamo di sfruttare la definizione del dominio fatta in fase di analisi per capire quale sia l'entry point del model, e di non realizzare un'unica macro-interfaccia che, spesso, finisce con l'essere il prodromo ad una ``God class''.
%
Consigliamo anche di separare bene controller e model, facendo attenzione a non includere nel secondo strategie d'uso che appartengono al primo.

In questa sezione vanno descritte, per ciascun componente architetturale che ruoli ricopre (due o tre ruoli al massimo), ed in che modo interagisce (ossia, scambia informazioni) con gli altri componenti dell'architettura.
%
Raccomandiamo di porre particolare attenzione al design dell'interazione fra view e controller: se ben progettato, sostituire in blocco la view non dovrebbe causare alcuna modifica nel controller (tantomeno nel model).

\subsection*{Elementi positivi}
\begin{itemize}
	\item Si mostrano pochi, mirati schemi UML dai quali si deduce con chiarezza quali sono le parti principali del software e come interagiscono fra loro.
	\item Si mette in evidenza se e come il pattern architetturale model-view-controller è stato applicato, anche con l'uso di un UML che mostri le interfacce principali ed i rapporti fra loro.
	\item Si discute se sia semplice o meno, con l'architettura scelta, sostituire in blocco la view: in un MVC ben fatto, controller e modello non dovrebbero in alcun modo cambiare se si transitasse da una libreria grafica ad un'altra (ad esempio, da Swing a JavaFX, o viceversa).
\end{itemize}

\subsection*{Elementi negativi}
\begin{itemize}
	\item L'architettura è fatta in modo che sia impossibile riusare il modello per un software diverso che affronta lo stesso problema.
	\item L'architettura è tale che l'aggiunta di una funzionalità sul controller impatta pesantemente su view e/o modello.
	\item L'architettura è tale che la sostituzione in blocco della view impatta sul controller o, peggio ancora, sul modello.
	\item Si presentano UML caotici, difficili da leggere.
	\item Si presentano UML in cui sono mostrati elementi di dettaglio non appartenenti all'architettura, ad esempio includenti campi o con metodi che non interessano la parte di interazione fra le componenti principali del software.
	\item Si presentano schemi UML con classi (nel senso UML del termine) che ``galleggiano'' nello schema, non connesse, ossia senza relazioni con il resto degli elementi inseriti.
	\item Si presentano elementi di design di dettaglio, ad esempio tutte le classi e interfacce del modello o della view.
	\item Si discutono aspetti implementativi, ad esempio eventuali librerie usate oppure dettagli di codice.
\end{itemize}

\subsection*{Esempio}

L'architettura di GLaDOS segue il pattern architetturale MVC.
%
Più nello specifico, a livello architetturale, si è scelto di utilizzare MVC in forma ``ECB'', ossia ``entity-control-boundary''\footnote{
	Si fa presente che il pattern ECB effettivamente esiste in letteratura come ``istanza'' di MVC, e chi volesse può utilizzarlo come reificazione di MVC.
}.
%
GLaDOS implementa l'interfaccia AI, ed è il controller del sistema.
Essendo una intelligenza artificiale, è una classe attiva.
%
GLaDOS accetta la registrazione di Input ed Output, che fanno parte della ``view'' di MVC, e sono il ``boundary'' di ECB.
Gli Input rappresentano delle nuove informazioni che vengono fornite all'IA, ad esempio delle modifiche nel valore di un sensore, oppure un comando da parte dell'operatore.
Questi input infatti forniscono eventi.
Ottenere un evento è un'operazione bloccante: chi la esegue resta in attesa di un effettivo evento.
Di fatto, quindi, GLaDOS si configura come entità \textit{reattiva}.
Ogni volta che c'è un cambio alla situazione del soggetto, GLaDOS notifica i suoi Output,
informandoli su quale sia la situazione corrente.
%
Conseguentemente, GLaDOS è un ``observable'' per Output.

\begin{figure}[h]
	\centering{}
	\includegraphics[width=\textwidth]{img/arch}
	\caption{Schema UML architetturale di GLaDOS. L'interfaccia \texttt{GLaDOS} è il controller del sistema, mentre \texttt{Input} ed \texttt{Output} sono le interfacce che mappano la view (o, più correttamente in questo specifico esempio, il boundary). Un'eventuale interfaccia grafica interattiva dovrà implementarle entrambe.}
	\label{img:goodarch}
\end{figure}

Con questa architettura, possono essere aggiunti un numero arbitrario di input ed output
all'intelligenza artificiale.
%
Ovviamente, mentre l'aggiunta di output è semplice e non richiede alcuna modifica all'IA, la
presenza di nuovi tipi di evento richiede invece in potenza aggiunte o rifiniture a GLaDOS.
%
Questo è dovuto al fatto che nuovi Input rappresentano di fatto nuovi elementi della business
logic, la cui alterazione od espansione inevitabilmente impatta il controller del progetto.

In \Cref{img:goodarch} è esemplificato il diagramma UML architetturale.

\end{comment}

%TODO: commentare questa parte del prof. quando avremo tutti finito di scrivere la nostra. -----------------  INIZIO -----------------------------------
\begin{comment}
In questa sezione si possono approfondire alcuni elementi del design con maggior dettaglio.
%
Mentre ci attendiamo principalmente (o solo) interfacce negli schemi UML delle sezioni precedenti, in questa sezione è necessario scendere in maggior dettaglio presentando la struttura di alcune sottoparti rilevanti dell'applicazione.
%
È molto importante che, descrivendo un problema, quando possibile si mostri che non si è re-inventata la ruota ma si è applicato un design pattern noto.
%
È assolutamente inutile, ed è anzi controproducente, descrivere classe-per-classe (o peggio ancora metodo-per-metodo) com'è fatto il vostro software: è un livello di dettaglio proprio della documentazione dell'API (deducibile dalla Javadoc).

\textbf{È necessario che ciascun membro del gruppo abbia una propria sezione di design dettagliato,
	di cui sarà il solo responsabile}.
%
Ciascun autore dovrà spiegare in modo corretto e giustamente approfondito (non troppo in dettaglio, non superficialmente) il proprio contributo.
%
È importante focalizzarsi sulle scelte che hanno un impatto positivo sul riuso, sull'estensibilità, e sulla chiarezza dell'applicazione.
%
Esattamente come nessun ingegnere meccanico presenta un solo foglio con l'intero progetto di una vettura di Formula 1, ma molteplici fogli di progetto che mostrano a livelli di dettaglio differenti le varie parti della vettura e le modalità di connessione fra le parti, così ci aspettiamo che voi, futuri ingegneri informatici, ci presentiate prima una visione globale del progetto, e via via siate in grado di dettagliare le singole parti, scartando i componenti che non interessano quella in esame.
%
Per continuare il parallelo con la vettura di Formula 1, se nei fogli di progetto che mostrano il
design delle sospensioni anteriori appaiono pezzi che appartengono al volante o al turbo, c'è una
chiara indicazione di qualche problema di design.

Usare correttamente i design pattern in questa sezione è molto importante: se vengono utilizzati correttamente, è molto probabile riuscire a progettare il software in modo corretto, estensibile, e riusabile.
%
Per ogni pattern utilizzato si presenti:
\begin{itemize}
	\item almeno un paragrafo che spieghi come è reificato nel progetto (ad esempio: nel caso di Template Method, qual è il metodo template; nel caso di Strategy, quale interfaccia del progetto rappresenta la strategia, e quali sono le sue implementazioni; nel caso di Decorator, qual è la classe astratta che fa da Decorator e quali sono le sue implementazioni concrete; eccetera);
	\item almeno uno schema UML che grafichi quanto sopra descritto.
\end{itemize}
%
La presenza di pattern di progettazione \emph{correttamente utilizzati} è valutata molto positivamente.
%
L'uso inappropriato è invece valutato negativamente: a tal proposito, si raccomanda di porre particolare attenzione all'abuso di Singleton, che, se usato in modo inappropriato, è di fatto un anti-pattern.

\subsection*{Elementi positivi}

\begin{itemize}
	\item Ogni membro del gruppo discute le proprie decisioni di progettazione, ed in particolare le azioni volte ad anticipare possibili cambiamenti futuri (ad esempio l'aggiunta di una nuova funzionalità, o il miglioramento di una esistente).
	\item Si identificano, utilizzano \textit{appropriatamente}, e descrivono come suggerito diversi design pattern.
	\item Ogni membro del gruppo identifica i pattern utilizzati nella sua sottoparte.
	\item Si mostrano gli aspetti di design più rilevanti dell'applicazione, mettendo in luce la maniera in cui si è costruita la soluzione ai problemi descritti nell'analisi.
	\item Si tralasciano aspetti strettamente implementativi e quelli non rilevanti, non mostrandoli negli schemi UML (ad esempio, campi privati) e non descrivendoli.
	\item Si mostrano le principali interazioni fra le varie componenti che collaborano alla soluzione di un determinato problema.
	\item Ciascun design pattern identificato presenta una piccola descrizione del problema calato
	nell'applicazione, uno schema UML che ne mostra la concretizzazione nelle classi del progetto, ed
	una breve descrizione della motivazione per cui tale pattern è stato scelto. Ad esempio, se si
	dichiara di aver usato Observer, è necessario specificare chi sia l'observable e chi l'observer; se
	si usa Template Method, è necessario indicare quale sia il metodo template; se si usa Strategy, è
	necessario identificare l'interfaccia che rappresenta la strategia; e via dicendo.
\end{itemize}

\subsection*{Elementi negativi}
\begin{itemize}
	\item Il design del modello risulta scorrelato dal problema descritto in analisi.
	\item Si tratta in modo prolisso, classe per classe, il software realizzato.
	\item Non si presentano schemi UML esemplificativi.
	\item Non si individuano design pattern, o si individuano in modo errato (si spaccia per design pattern qualcosa che non lo è).
	\item Si utilizzano design pattern in modo inopportuno. Un esempio classico è l'abuso di
	Singleton per entità che possono essere univoche ma non devono necessariamente esserlo. Si rammenta
	che Singleton ha senso nel secondo caso (ad esempio \texttt{System} e \texttt{Runtime} sono
	singleton), mentre rischia di essere un problema nel secondo. Ad esempio, se si rendesse singleton
	il motore di un videogioco, sarebbe impossibile riusarlo per costruire un server per partite online
	(dove, presumibilmente, si gestiscono parallelamente più partite).
	\item Si producono schemi UML caotici e difficili da leggere, che comprendono inutili elementi
	di dettaglio.
	\item Si presentano schemi UML con classi (nel senso UML del termine) che ``galleggiano'' nello schema, non connesse, ossia senza relazioni con il resto degli elementi inseriti.
	\item Si tratta in modo inutilmente prolisso la divisione in package, elencando ad esempio le classi una per una.
\end{itemize}

\subsection*{Esempio minimale (e quindi parziale) di sezione di progetto con UML ben realizzati}

In questa sezione ci si concentrerà sugli aspetti di personalità e sul funzionamento del reporting di GLaDOS.

Il sistema per la gestione della personalità utilizza il pattern Strategy, come da
\Cref{img:strategy}: le implementazioni di \texttt{Personality} possono essere modificate, e la
modifica impatta direttamente sul comportamento di GLaDOS.

\begin{figure}[h]
	\centering{}
	\includegraphics[width=\textwidth]{img/strategy}
	\caption{Rappresentazione UML del pattern Strategy per la personalità di GLaDOS}
	\label{img:strategy}
\end{figure}

\begin{figure}[h]
	\centering{}
	\includegraphics[width=\textwidth]{img/template}
	\caption{Rappresentazione UML dell'applicazione del pattern Template Method alla gerarchia delle Personalità}
	\label{img:template}
\end{figure}

Sono state attualmente implementate due personalità, una buona ed una cattiva.
Quella buona restituisce sempre una torta vera, mentre quella cattiva restituisce sempre la
promessa di una torta che verrà in realtà disattesa.
Dato che le due personalità differiscono solo per il comportamento da effettuarsi in caso di percorso completato con successo, è stato utilizzato il pattern template method per massimizzare il riuso, come da \Cref{img:template}.
Il metodo template è \texttt{onSuccess()}, che chiama un metodo astratto e protetto
\texttt{makeCake()}.

\begin{figure}[h]
	\centering{}
	\includegraphics[width=.7\textwidth]{img/observer}
	\caption{Il pattern Observer è usato per consentire a GLaDOS di informare tutti i sistemi di output in ascolto}
	\label{img:observer}
\end{figure}

Per quanto riguarda il reporting, è stato utilizzato il pattern Observer per consentire la
comunicazione uno-a-molti fra \texttt{GLaDOS} ed i sistemi di output.
%
\texttt{GLaDOS} è observable, e le istanze di \texttt{Input} sono observer.
%
Il suo utilizzo è esemplificato in \Cref{img:observer}

\subsection*{Contro-esempio: pessimo diagramma UML}

In \Cref{img:badarch} è mostrato il modo \textbf{sbagliato} di fare le cose.
%
Questo schema è fatto male perché:
\begin{itemize}
	\item È caotico.
	\item È difficile da leggere e capire.
	\item Vi sono troppe classi, e non si capisce bene quali siano i rapporti che intercorrono fra loro.
	\item Si mostrano elementi implementativi irrilevanti, come i campi e i metodi privati nella classe \texttt{AbstractEnvironment}.
	\item Se l'intenzione era quella di costruire un diagramma architetturale, allora lo schema è ancora più sbagliato, perché mostra pezzi di implementazione.
	\item Una delle classi, in alto al centro, galleggia nello schema, non connessa a nessuna altra classe, e di fatto costituisce da sola un secondo schema UML scorrelato al resto
	\item Le interfacce presentano tutti i metodi e non una selezione che aiuti il lettore a capire quale parte del sistema si vuol mostrare.
\end{itemize}


\begin{figure}[h]
	\centering{}
	\includegraphics[width=\textwidth]{img/badarch}
	\caption{Schema UML mal fatto e con una pessima descrizione, che non aiuta a capire. Don't try this at home.}
	\label{img:badarch}
\end{figure}

%TODO: commentare questa parte del prof. quando avremo tutti finito di scrivere la nostra. -----------------  FINE -----------------------------------
	content...
\end{comment}

% ----------------- ALESSANDRO PIOGGIA -----------------------------------------

\newpage

\section{Design dettagliato}

\subsection*{Alessandro Pioggia}
\subsubsection{Physical objects}
Lo scopo iniziale del progetto è stato quello di creare delle vere e proprie entità di gioco(Players, Enemies, Obstacles, Items), che potessero popolare la mappa e interagire fra loro.
La mia parte richiedeva che io costruissi il core delle entità fisiche di gioco(oltre all'implementazione di alcune di esse), in modo da poter creare una struttura solida alla quale potessero fare riferimento i colleghi, sfruttando il principio della generalizzazione.
L'interfaccia \textbf{PhysicalObject} rappresenta la struttura base di una entità di gioco, la quale è composta da una dimensione, una posizione e contiene un riferimento all'ambiente di gioco, con relativa implementazione. In prima istanza credevamo fosse opportuno suddividere le GameEntity statiche da quelle dinamiche, separandole in due classi, però abbiamo notato che a livello pratico non ne avevamo alcun beneficio. 

\begin{figure}[H]
	\centering{}
	\includegraphics[width=320pt]{img/physicalObject}
	\label{img:physicalObject}
	\caption{Schema UML rappresentante l'interfaccia PhysicalObject con relative dipendenze. \\}
\end{figure}

\newpage

\subsubsection{Item}
Gli \textbf{Item} sono entità presenti all'interno dell'ambiente di gioco, le quali possono essere raccolte dal main player, il quale ne subisce l'effetto, gestito dal mio collega Leon.
Per semplificare l'istanziamento ho deciso di utilizzare il factory pattern, il quale è tornato molto utile e ha ridotto la verbosità. Similmente ho concepito la classe \textbf{Obstacle}.

\begin{figure}[H]
	\centering{}
	\includegraphics[width=\textwidth]{img/item}
	\label{img:item.png}
	\caption{Schema UML rappresentante gli Item di gioco\\}
\end{figure}

\begin{figure}[H]
	\centering{}
	\includegraphics[width=\textwidth]{img/ItemFactory}
	\label{img:ItemFactory.png}
	\caption{Schema UML rappresentante il factory pattern applicato agli Item\\}
\end{figure}

\newpage

\subsubsection{Menu}
Il main menu non è altro che il menù principale, ovvero quello che viene visualizzato all'avvio dell'applicazione e permette all'utente di decidere se e quando iniziare a giocare.
Per realizzarlo ho deciso di sfruttare scene builder, software che mi ha permesso di generare i file fxml, ai quali sono stati associati dei controller, permettendomi di solidificare il concetto di separation of concerns. Ho deciso di creare una classe PageLoaderImpl (che implementa l'interfaccia PageLoader) per caricare agilmente gli fxml.

\begin{figure}[H]
	\centering{}
	\includegraphics[width=480pt]{img/main_menu}
	\label{img:main_menu.png}
	\caption{Schema UML rappresentante il main menu\\}
\end{figure}

\newpage

\subsubsection{PhysicalObjectSprites}

Oltre alla parte di model, in comune accordo abbiamo deciso di spartirci la creazione delle relative sprites, per fare ciò ho deciso di creare uno scheletro, in modo che i miei compagni potessero fruirne per rendere la struttura più pulita. A questo proposito ho deciso di creare una classe chiamata \textbf{PhysicalObjectSprite}, che contiene metodi, validi per qualsiasi entità di gioco, per la creazione di sprite. Per rendere il tutto più intuitivo e semplice ho deciso di creare una factory, in modo che i miei compagni potessero aggiungere i propri metodi.

\begin{figure}[H]
	\centering{}
	\includegraphics[width=\textwidth]{img/PhysicalObjectSprites.drawio}
	\label{img:PhysicalObjectSprites.drawio.png}
	\caption{Schema UML rappresentante il main menu\\}
\end{figure}

\subsubsection{Sounds}
L'ultima componente del progetto che ho gestito riguarda i suoni, per fare ciò ho creato una semplice classe SoundImpl (che implementa l'interfaccia Sound). Per rendere il tutto fruibile, come visto nei casi precedenti, ho deciso di sfruttare il factory pattern(omesso dall'UML perchè la struttura è identica alle altre già presentate).

\begin{figure}[H]
	\centering{}
	\includegraphics[width=\textwidth]{img/Sounds.drawio}
	\label{img:Sounds.drawio.png}
	\caption{Schema UML rappresentante il main menu\\}
\end{figure}

% ----------------- LEON BAIOCCHI -----------------------------------------

\newpage

\subsection*{Leon Baiocchi}

\subsubsection{Game environment}
Inizialmente è stato essenziale trovare una modalità secondo la quale organizzare tutte le varie
entità di gioco presenti così da poterle gestire agevolmente all'interno dell'ambiente di gioco.
Questa ricerca mi ha portato a sviluppare il concetto di \textbf{Environment}, ossia una sorta di wrapper di tutti i componenti lato model, quindi entità, meccaniche(eventi) e fisica di gioco(gravità, collisioni).
Questi componenti vengono gestiti corrispettivamente da: \textbf{EntityManager}, che si occupa della gestione delle varie entità all'interno di una struttura dati definita in \textit{AbstractContainer}; campo di tipo \textit{GameEventListener}, viene utilizzato per far sì che il GameEnvironment possa notificare ad un listener i propri eventi.
Le collisioni vengono considerate come degli eventi insieme all'evento di game over.

\begin{figure}[H]
	\centering{}
	\includegraphics[width=\textwidth]{img/game_environment_uml.png}
	\label{img:game_environment_uml.png}
	\caption{Schema UML di GameEnvironment\\}
\end{figure}

Degno di nota è il metodo \textit{updateState()} di Environment il quale si occupa di aggiornare l'ambiente di gioco ad ogni frame.
Quest'ultimo ha inoltre delle dimensioni che indicano altezza e larghezza dell'ambientazione.
E' presente infine un sistema di rilevazione delle collisioni con relativo meccanismo di notifica verso un GameEventListener, progettato e sviluppato per garantire il corretto funzionamento dell'algoritmo di collision detection sviluppato dal collega Federico.
Ho utilizzato il pattern \textbf{Strategy} per stabilire correttamente e distintamente i vari compiti di ogni classe come ad esempio è possibile notare con l'interfaccia Environment, che sarebbe la strategy.
Oltre ad esso, all'interno di EntityManager vi è un \textbf{Builder} che permette di costruire un EntityManager da zero o a partire da uno esistente.

\subsubsection{Game engine}
Successivamente insieme agli altri membri del team ci siamo resi conto di dover collegare le varie parti dell'applicazione come ad esempio model e view, ed in particolare dare vita al gioco.
In prima battuta mi sono ritrovato a creare una classe che potesse collegare semplicemente parte logica e parte grafica in modo da dare vita alla struttura MVC, ma dopo poco ho ritenuto opportuno ampliare la suddetta classe donandogli 3 principali interfacce, ognuna adibita ad un determinato aspetto da gestire.
Questa classe viene definita all'interno del nostro progetto come il cuore pulsante dell'applicazione in quanto permette di temporizzare l'esecuzione del gioco attraverso \textbf{timer} e \textbf{main loop}.
Quest'ultimo al suo interno esegue 3 differenti funzioni: \textit{processare} comandi di input, \textit{aggiornare} il model, \textit{renderizzare} la view; Esse si ripetono ciclicamente fino al game over.
Anche qui viene utilizzato il pattern \textbf{Strategy} per garantire una strategia alle singole classi, mentre una novità, in termini di pattern usati, rispetto a GameEnvironment sta nel pattern \textbf{Command} utilizzato per ricevere comandi di input, esso viene adoperato dall'interfaccia Command.

\begin{figure}[H]
	\centering{}
	\includegraphics[width=\textwidth]{img/game_engine_controllers_uml.png}
	\label{img:game_engine_controllers_uml.png}
	\caption{Schema UML di Game Engine\\}
\end{figure}

\subsubsection{Generazione mappa}
La generazione della mappa è stato fulcro di innumerevoli discussioni all'interno del team, culminate con la scelta di rappresentare le varie mappe, con entità al loro interno, testualmente, tramite una serie di caratteri, ognuno dei quali rappresentante una determinata entità.
Questo aspetto nello specifico è stato curato dal collega Luca, il quale ha generato le varie mappe testuali e trovato il modo di caricarle(riferirsi a LevelLoader), dopodichè il mio compito è stato quello di prendere la mappa e trasformarla in una mappa di entità di gioco.
Ed è per questo che ho scelto di dare una strategy(interfaccia) come LevelGenerator a EnvironmentGenerator al quale sono poi stati aggiunti un Environment, espressione della mappa testuale, e le relative factories per la creazione di entità di gioco.

\begin{figure}[H]
	\centering{}
	\includegraphics[width=\textwidth]{img/environment_generator_uml.png}
	\label{img:environment_generator_uml.png}
	\caption{Schema UML di Environment Generator\\}
\end{figure}

\subsubsection{Effetti}
Gli effetti in un gioco dinamico e ad eventi possono essere molto utili, sia dal punto di vista del giocatore sia dal punto di vista del programmatore.
Per questo ho scelto di introdurli, in modo da garantire un maggiore incapsulamento oltre ad offire una maggiore estensibilità d'uso. 
Effects è inoltre interfaccia funzionale, ciò presenta maggiori opportunità espressive come ho poi potuto osservare durante la fase di utilizzo degli effetti insieme al team, infatti essa può essere utilizzata per creare ed applicare effetti personalizzabili. In questa circostanza mi sono avvalso di una \textbf{factory} per la creazione di effetti prestabiliti.

\begin{figure}[H]
	\centering{}
	\includegraphics[width=\textwidth]{img/effects_uml.png}
	\label{img:effects_uml.png}
	\caption{Schema UML dei vari effetti\\}
\end{figure}


% ----------------- FEDERICO BRUNELLI -----------------------------------------

\newpage

\subsection*{Federico Brunelli}

\textsf{\small Il compito che ho avuto in carica è stato quello di gestire le weapon, la parte logica e la renderizzazione grafica, il cui scopo è stato quello di interagire con il player; i bullet, ugualmente ho sviluppato parte e logica e sua prospettiva visiva.}\\

\textsf{\small Entrambi questi due oggetti estendevano GameEntity, la classe madre degli entità di gioco.
Il secondo obiettivo del mio compito comprendeva la gestione delle collisioni, lato model, la quale veniva ulteririormente integrata con gli eventi della logica di gioco, gestiti dal collega Leon.
Infine ho sviluppato il menù di pausa richiamato durante il gioco premendo un comando da tastiera.}

\subsubsection*{Weapons and Bullet}

Le \textbf {weapon} sono entità dinamiche all'interno del gioco, rendono possibile un'interazione diretta con il player a livello di gameplay.
Ogni \textbf{weapon} ha diverse funzionalità comuni a tutti i tipi ed inoltre si interfaccia con \textbf{Bullet}, con il quale permette la funzionalità primaria di un'arma ovvero sparare.\\

Il \textbf{Bullet} è l'unica entità che non viene istanziata all'avvio del gioco ed infatti la sua creazione avviene attraverso un input da tastiera.

Per entrambe le entità ho adottato il pattern Factory per creare diversi tipi con caratterristiche differenti ma stesse funzionalità.

\begin{figure}[H]
	\centering{}
	\includegraphics[width=\textwidth]{./img/Weapon.png}
	\label{img:Weapon.png}
	\caption{Schema UML rappresentante \textbf{Weapon}}
\end{figure}

\begin{figure}[H]
	\centering{}
	\includegraphics[width=\textwidth]{./img/Bullet.png}
	\label{img:Weapon.png}
	\caption{Schema UML rappresentante \textbf{Bullet}}
\end{figure}

\subsubsection*{Collision}

Per gestire le interazioni tra le varie entità nel mondo di gioco mi sono avvalso di una classe statica in grado di poter verificare l'avvenuta collisione.
Ho preso spunto dall'esempio del professore Ricci \url{https://bitbucket.org/aricci303/2021-game-prog-basics/src/master/Game-As-A-Lab-Step-03-collisions/}\\

Utilizzando le le informazioni prelevate dalle entità si può rilevare una \textbf{Collision}, la quale scaturirà degli eventi in base alle tipologie di oggetti che collidono.  

\begin{figure}[H]
	\centering{}
	\includegraphics[width=\textwidth]{./img/Collision.png}
	\label{img:Collision.png}
	\caption{Schema UML rappresentante la classe \textbf{Collision}}
\end{figure}

\subsubsection*{Menù di pausa}
Sfruttando l'architettura proposta per i menù dal mio collega Alessandro ho sviluppato il menù di pausa, al quale si può accedere durante il gioco attraverso il comando di Escape.
Esso permette all'utente di poter modificare le impostazioni, tornare al gioco oppure uscire dall'applicazione.
Attraverso l'evento di resume, il comando del gioco torna al controller principale e il gioco prosegue da dove lo si era lasciato.

\begin{figure}[H]
	\centering{}
	\includegraphics[width=\textwidth]{./img/PauseMenu}
	\label{img:PauseMenu.png}
	\caption{Schema UML rappresentante il menù di pausa}
\end{figure}


% ----------------- LUCA RENGO -----------------------------------------

\newpage

\subsection*{Luca Rengo}
a
\textsf{\small La mia parte riguardava l'implementazione dei personaggi di gioco e dei diversi aspetti riguardanti la generazione della mappa e dei suoi componenti a livello di \emph{View}.}\\

\textsf{\small Mi competeva, inoltre, l'inizializzazione delle varie scene di gioco, dell'implementazione delle sprites, del salvataggio dei punteggi e delle statistiche completati dal giocatore.}\\ 
%della generazione della mappa a livello di \emph{View}.}\\

\subsubsection*{Characters}

\textsf{\small Per quanto concerne l'implementazione dei personaggi di gioco, ho sviluppato un'interfaccia \emph{Characters} che pone a tutte le figure l'implementazione di un contratto con le varie azioni comuni, i vari metodi che un personaggio può eseguire.}\\

\textsf{\small Questo è stato trattato dalle classi \emph{Player} ed \emph{Enemy} che contengono le proprietà e caratteristiche dei personaggi come la loro vita, il mana, il nome, le loro abilità e capacità come quella di muoversi e saltare.}\\

\textsf{\small Ho utilizzato poi un enum, \emph{EntityList}, per poter rappresentare diversi tipi di personaggi con diverse caratteristiche che ho settato nel metodo \emph{setPlayerType()} e \emph{setEnemyType()} delle rispettive classi. }\\

\textsf{\small Mi sono avvalso, inoltre, del pattern architetturale \textbf{Factory} per raccogliere le varie tipologie di \emph{Player} ed \emph{Enemy} attraverso l'interfaccia \emph{FactoryCharacters} e la sua implementazione \emph{FactoryCharactersImpl} per riorganizzare meglio i vari personaggi del gioco e rendere la loro creazione più chiara e semplice, evitando così di dover passare, ogni volta, un eccessivo numero di parametri da inizializzare.}

%\enlargethispage{1\linewidth}
\begin{figure}[H]
	\centering{}
	\includegraphics[width=1.3\textwidth]{./img/characters_uml.png} 
	\caption{Schema UML del \emph{Model} relativo ai \emph{Characters}.}
	\label{img:uml_model_characters}
\end{figure}

\subsubsection*{Mappa di gioco} %TODO: approfondire la spiegazione. Descrivere le difficoltà incontrate e le soluzioni.

\textsf{\small Per quanto riguarda la \emph{Mappa} mi sono occupato degli aspetti della \emph{View}.}\\

\textsf{\small E' presente l'interfaccia \emph{GameView} che viene implementata dalla classe astratta \emph{AbstractScene} che ha il compito di rappresentare una generica scena del gioco, come la mappa o i crediti del gioco. Questa è ereditata dalla Classe \emph{MapScene} che implementa una specifica scena del gioco, ovvero quella della mappa, inizializzando tutte le sprites delle varie entità di gioco e generandole sullo schermo.}\\

\textsf{\small In \emph{MapScene} vengono generate le sprites dalle classi \emph{Platform}, \emph{Coin}, \emph{MainEnemy}, \emph{MainPlayer} con la sua animazione implementata in \emph{SpriteAnimation}.}\\

\textsf{\small Queste entità vengono posizionate in una precisa posizione in base alla locazione di un carattere in un array di stringhe che si trovano in dei files .txt che vengono caricati dalla classe \emph{LevelLoader}.} %TODO: sistemare, scrivere meglio.

\textsf{\small Ad ogni entità del gioco è associato un carattere (un numero o un simbolo) che si trovano files .txt nella directory \emph{levels/}.}\\ %TODO: anche qui.

\textsf{\small Le classi \emph{Platform} e \emph{Coin} sono simili ed entrambe hanno un proprio enum per le proprie varie tipologie e utilizzano una ImageView per settare l'immagine, le proprietà e le posizioni sullo schermo.}\\

\textsf{\small \emph{MainEnemy} è una semplice ImageView statica mentre \emph{MainPlayer} è una ImageView dinamica, ovvero con un'animazione.}
\textsf{\small \emph{SpriteAnimation} è la classe che carica da \emph{MainPlayer} l'immagine e le sue caratteristiche (come width dell'immagine, height, ecc..) ed interpola le varie immagini della spritesheet del giocatore per creare la sua animazione che dura tot millisecondi.}\\

\textsf{\small  Quale sfondo della mappa da mostrare e la relativa piattaforma in tema e quale moneta vengono settate nella classe \emph{BackgroundMap} che tiene traccia di questi elementi della View.}\\

\begin{figure}[H]
	\centering{} 
	\includegraphics[width=.5\textwidth]{./img/level_uml.png} 
	\caption{Schema UML della generazione dei livelli in \emph{LevelLoader}, \emph{LevelGenerator} e \emph{Environment Generator}.}
	\label{img:level_uml}
\end{figure}

\begin{figure}[H]
	\centering{} %TODO: UML MapScene.
	\includegraphics[width=1\textwidth]{./img/scenes_uml.png} 
	\caption{Schema UML della \emph{View} relativa alla \emph{AbstractScene}, \emph{MapScene}, \emph{MainPlayer} e \emph{MainEnemy}.}
	\label{img:scenes_uml}
\end{figure}

\begin{figure}[H]
	\centering{}
	\includegraphics[width=1.3\textwidth]{./img/map_uml.png} 
	\caption{Schema UML della \emph{View} relativa alla \emph{Map}, alle \emph{Platform} e ai \emph{Coin}.}
	\label{img:map_uml}
\end{figure}

%TODO: parlare della Mappa (Map, MapScene, AbstractScene), del MainPlayer, SpriteAnimation, MainEnemy, Platform, Coin. LevelData

\subsubsection*{Salvataggio}

\textsf{\small Per quanto riguarda l'operazione di salvataggio delle statistiche di gioco, mi sono avvalso della classe \emph{Save} che crea un file di salvataggio in cui vengono contenuti il nome dei giocatori e i loro relativi punteggi e data in cui la partita è stata effettuata.} \\

\textsf{\small Nel \emph{GameOverEvent} quando il player muore e quindi il gioco finisce, viene chiamato il metodo \emph{saveGameStatistics()} e gli si passa il nome, il punteggio e la data attraverso un \emph{SimpleDateFormat}.}

\textsf{\small Per fare questo, usufruisco di un \emph{jsonArray} e se nel file erano già presenti dei dati, li decripto e li appendo e li riencripto altrimenti aggiungo i dati e li encripto.} \\

\textsf{\small Per poter caricare questi dati dal file, lo decripto, faccio il parsing della stringa in chiaro attraverso un \emph{jsonParser} e ottenendo gli \emph{jsonArray} e da questo formo e restituisco una \emph{Mappa<String, MutablePair<String,String>>}.}

\textsf{\small Inoltre, ho un metodo per modificare i dati che erano stati precedentemente salvati per evitare di dover sovrascrivere il file ogni volta.}\\

\textsf{\small Per quanto riguarda il salvataggio e il caricamento delle impostazioni di gioco ho usato il medesimo meccanismo, ma usando dei \emph{jsonObject} perchè ogni dato può essere considerato in maniera separata.}

\textsf{\small Inoltre, le impostazioni vengono poi automaticamente recuperate e caricate nel menu delle Impostazioni all'avvio del gioco attraverso la classe \emph{SettingsController} e in cui, una volta premuto Salva vengono salvate su file e mostra a schermata un \emph{Alert} con successo se l'operazione è andata a buon fine altrimenti un \emph{Alert} di errore.} \\

\textsf{\small Per quanto riguarda i livelli non vengono memorizzati come .json, perché non ho voluto salvarli tutti nello stesso file, ma in file separati e quindi ho optato per lasciarli in .txt ed come sempre criptarli. }

\textsf{\small Ogni file di ogni livello è composto da righe (matrici) di caratteri, ciascun carattere rappresenta un'entità di gioco, queste sono segnate nell'enum \emph{LevelEntity}.} \\

\textsf{\small Ci son due tipi metodi per caricare i files, uno per caricare il livello in .txt, questo può essere utile per testare i livelli e poterli modificare, cosa non possibile con i files criptati ed uno che decripta e carica i files .dat.} 

\begin{itemize}
	\item \textsf{\small Per quanto riguarda i .txt usufruisco di un \emph{BufferReader} per leggere riga per riga del file e restituirle.} 
	\item \textsf{\small Mentre per i files .dat decripto il livello, ottengo una stringa in chiaro e attraverso un'espressione \emph{regex} separo riga per riga e dopodichè le restituisco.}  \\
\end{itemize}

\textsf{\small Ho poi un metodo per encriptare i files se sono presenti dei files in .txt} \\

\textsf{\small Infine, ho un metodo per resettare il file in base alla path passata come parametro e cancellare tutti i dati che erano stati immagazzinati.}\\

\subsection{Criptare e Decriptare i dati del salvataggio}

\textsf{\small La classe \emph{SecureData} si occupa di criptare e decriptare dati e files.} \\

\textsf{\small Qui, usufruisco di un \emph{SecureRandom} per generare un numero pseudo-casuale per creare un IV, (initialization vector) che serve per aggiungere casualità al processo di criptazione, e la salatura che serve per aggiungere dei bytes aggiuntivi alla password prima che passi per l'algoritmo di hashing. } \\

\textsf{\small Poi genero la password attraverso una \emph{SecretKey} fornendo l'algoritmo, la password, la salatura, il contatore delle iterazioni e lo spazio della chiave e lo standard di criptazione, in questo caso AES (\emph{Advanced Encryption System}).} \\

\textsf{\small Per la criptazione di dati, passiamo al metodo il messaggio e la password che vogliamo usare, poi otteniamo l'iv e la salatura e la chiave dopodichè settiamo la modalità del cifrario su \textbf{ENCRYPT} e gli passiamo la chiave e un \emph{GCMParameterSpec} che specifica un insieme di parametri necessari al cifrario usando la modalità \textbf{Galois/Counter Mode} e dopodiché criptiamo il nostro messaggio e lo restituiamo.} \\

\textsf{\small Per la decriptazione, recuperiamo dal messaggio criptato, la salatura e l'iv e ciò che rimane del messaggio, otteniamo la chiave attraverso la password che deve essere la stessa usata per la criptazione, dopodichè col cifrario in modalità \textbf{DECRYPT} decriptiamo il messaggio e lo restituiamo.} \\

\textsf{\small Per criptare direttamente il file leggiamo tutti i bytes di esso e li criptiamo utilizzando il metodo \emph{encrypt} dopodichè li scriviamo sul file.} 

\textsf{\small Per decriptare direttamente il file leggiamo tutti i bytes e chiamiamo il metodo \emph{decrypt} e restituiamo il messaggio.} \\

\begin{figure}[H]
	\centering{}
	\includegraphics[width=.5\textwidth]{./img/save_uml.png} 
	\caption{Schema UML del \emph{Model} relativo al \emph{Salvataggio} del gioco.}
	\label{img:save_uml}
\end{figure}

\subsection{Lingue del gioco}

\textsf{\small Per quanto concerne la traduzione del gioco ho adoperato \textbf{JavaFX Internazionalization} che permette di lavorare sulle stringhe dei files fxml e di cambiarle in base alla lingua selezionata nel menu di impostazioni.} \\

\textsf{\small Le traduzioni delle varie lingue si trovano in dei files bundles \textbf{.properties}. In \emph{SettingsController} possiamo caricare e settare la lingua dal file con l'enum \emph{Languages}, poi quando viene caricata una nuova pagina del menù viene recuperato dal file delle impostazioni la lingua e così utilizza il file \textbf{.properties} corrispondente.} \\